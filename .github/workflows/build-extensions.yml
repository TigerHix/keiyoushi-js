name: Build Extensions

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all extensions'
        required: false
        default: false
        type: boolean
      extensions:
        description: 'Specific extensions (comma-separated, e.g., en/mangapill,ja/shonenjumpplus)'
        required: false
        default: ''
        type: string
      skip_tests:
        description: 'Skip extension tests'
        required: false
        default: false
        type: boolean
  repository_dispatch:
    types: [tachiyomi-js-update]
  push:
    branches: [main]
    paths:
      - 'scripts/**'
      - '.github/workflows/build-extensions.yml'

concurrency:
  group: build-extensions
  cancel-in-progress: true

env:
  TACHIYOMI_JS_REPO: https://github.com/nemu-pm/tachiyomi-js
  EXTENSIONS_REPO: https://github.com/keiyoushi/extensions-source

jobs:
  # ============================================================================
  # Check upstream for changes
  # ============================================================================
  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      keiyoushi_commit: ${{ steps.check.outputs.keiyoushi_commit }}
    steps:
      - name: Check for upstream changes
        id: check
        run: |
          LAST="${{ vars.KEIYOUSHI_LAST_COMMIT }}"
          CURRENT=$(git ls-remote ${{ env.EXTENSIONS_REPO }} HEAD | cut -f1)
          
          echo "Last: $LAST"
          echo "Current: $CURRENT"
          echo "keiyoushi_commit=$CURRENT" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ -z "$LAST" ] || [ "$LAST" != "$CURRENT" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Detect changed extensions
  # ============================================================================
  detect:
    needs: check-upstream
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    outputs:
      extensions: ${{ steps.detect.outputs.extensions }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
      matrix: ${{ steps.detect.outputs.matrix }}
    
    steps:
      - name: Clone extensions source (shallow)
        run: git clone --depth=50 ${{ env.EXTENSIONS_REPO }} extensions-source
      
      - name: Detect changed extensions
        id: detect
        run: |
          cd extensions-source
          LAST_COMMIT="${{ vars.KEIYOUSHI_LAST_COMMIT }}"
          
          if [ "${{ inputs.force_rebuild }}" == "true" ]; then
            EXTENSIONS=$(find src -mindepth 2 -maxdepth 2 -type d | sed 's|src/||' | sort | tr '\n' ',' | sed 's/,$//')
          elif [ -n "${{ inputs.extensions }}" ]; then
            EXTENSIONS="${{ inputs.extensions }}"
          elif [ -z "$LAST_COMMIT" ]; then
            EXTENSIONS=$(find src -mindepth 2 -maxdepth 2 -type d | sed 's|src/||' | sort | tr '\n' ',' | sed 's/,$//')
          elif ! git cat-file -e "$LAST_COMMIT" 2>/dev/null; then
            # Commit not in shallow clone, fetch more
            git fetch --depth=200 origin main
            if ! git cat-file -e "$LAST_COMMIT" 2>/dev/null; then
              EXTENSIONS=$(find src -mindepth 2 -maxdepth 2 -type d | sed 's|src/||' | sort | tr '\n' ',' | sed 's/,$//')
            else
              CHANGED_FILES=$(git diff --name-only "$LAST_COMMIT" HEAD -- src/ 2>/dev/null || echo "")
              EXTENSIONS=$(echo "$CHANGED_FILES" | grep '^src/' | cut -d'/' -f2-3 | sort -u | tr '\n' ',' | sed 's/,$//')
            fi
          else
            CHANGED_FILES=$(git diff --name-only "$LAST_COMMIT" HEAD -- src/ 2>/dev/null || echo "")
            if [ -z "$CHANGED_FILES" ]; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "extensions=" >> $GITHUB_OUTPUT
              echo "matrix=[]" >> $GITHUB_OUTPUT
              exit 0
            fi
            EXTENSIONS=$(echo "$CHANGED_FILES" | grep '^src/' | cut -d'/' -f2-3 | sort -u | tr '\n' ',' | sed 's/,$//')
          fi
          
          echo "extensions=$EXTENSIONS" >> $GITHUB_OUTPUT
          
          COUNT=$(echo "$EXTENSIONS" | tr ',' '\n' | grep -c . || echo 0)
          if [ "$COUNT" -eq 0 ]; then
            echo "matrix=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
          elif [ "$COUNT" -le 10 ]; then
            echo "matrix=[0]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          elif [ "$COUNT" -le 50 ]; then
            echo "matrix=[0,1]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          elif [ "$COUNT" -le 200 ]; then
            echo "matrix=[0,1,2,3]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "matrix=[0,1,2,3,4,5,6,7]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Build extensions
  # ============================================================================
  build:
    needs: detect
    if: needs.detect.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        chunk: ${{ fromJson(needs.detect.outputs.matrix) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Clone tachiyomi-js
        run: git clone --depth=1 ${{ env.TACHIYOMI_JS_REPO }} tachiyomi-js
      
      - name: Clone extensions source
        run: git clone --depth=1 ${{ env.EXTENSIONS_REPO }} extensions-source
      
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
      
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
      
      - name: Install dependencies
        run: |
          bun install
          cd tachiyomi-js/cli && bun install
      
      - name: Make gradlew executable
        run: chmod +x tachiyomi-js/shim/gradlew tachiyomi-js/compiler/gradlew
      
      - name: Create config
        run: |
          cat > tachiyomi.config.json << EOF
          {
            "source": "${{ github.workspace }}/extensions-source",
            "output": "${{ github.workspace }}/dist/extensions"
          }
          EOF
      
      - name: Build and test extensions (chunk ${{ matrix.chunk }})
        env:
          TACHIYOMI_OUTPUT: ${{ github.workspace }}/dist/extensions
          EXTENSIONS_SOURCE: ${{ github.workspace }}/extensions-source
          SKIP_TESTS: ${{ inputs.skip_tests }}
        run: |
          EXTENSIONS="${{ needs.detect.outputs.extensions }}"
          IFS=',' read -ra EXT_ARRAY <<< "$EXTENSIONS"
          TOTAL=${#EXT_ARRAY[@]}
          
          MATRIX='${{ needs.detect.outputs.matrix }}'
          NUM_CHUNKS=$(echo "$MATRIX" | jq 'length')
          CHUNK_SIZE=$(( (TOTAL + NUM_CHUNKS - 1) / NUM_CHUNKS ))
          START=$(( ${{ matrix.chunk }} * CHUNK_SIZE ))
          END=$(( START + CHUNK_SIZE ))
          
          if [ $START -ge $TOTAL ]; then
            echo "No extensions in this chunk"
            echo '{"chunk": ${{ matrix.chunk }}, "extensions": []}' > "chunk-${{ matrix.chunk }}-results.json"
            exit 0
          fi
          
          mkdir -p dist/extensions test-results
          
          # Track built extensions for result collection
          declare -a BUILT_EXTS
          declare -A BUILD_RESULTS  # associative array: EXT -> JSON
          
          for i in $(seq $START $(( END - 1 ))); do
            if [ $i -ge $TOTAL ]; then break; fi
            EXT="${EXT_ARRAY[$i]}"
            
            echo "::group::Building $EXT"
            BUILD_START=$(date +%s%3N)
            BUILD_OUTPUT=$(mktemp)
            BUILD_STATUS="success"
            
            if ./tachiyomi-js/compiler/gradlew -p tachiyomi-js/compiler devBuild \
                -Pextension="$EXT" \
                -PextensionsRoot="${{ github.workspace }}/extensions-source" \
                -PoutputDir="${{ github.workspace }}/dist/extensions" \
                --build-cache --parallel --configuration-cache > "$BUILD_OUTPUT" 2>&1; then
              echo "âœ… Built $EXT"
              
              # Post-process manifest for this extension
              bun scripts/postprocess-manifests.ts "$EXT" 2>/dev/null || true
              
              # Start test in background (unless skipped)
              if [ "$SKIP_TESTS" != "true" ]; then
                EXT_SAFE="${EXT//\//-}"
                (
                  TEST_OUT=$(timeout 60 ./tachiyomi-js/cli/bin.ts test all "$EXT" --json 2>&1 || true)
                  echo "$TEST_OUT" > "test-results/${EXT_SAFE}.json"
                ) &
                echo "  ðŸ§ª Test started in background"
              fi
            else
              BUILD_STATUS="failed"
              echo "âŒ $EXT"
              cat "$BUILD_OUTPUT"
            fi
            
            BUILD_TIME=$(($(date +%s%3N) - BUILD_START))
            echo "::endgroup::"
            
            # Store build result
            BUILD_ERROR=$([ "$BUILD_STATUS" = "failed" ] && cat "$BUILD_OUTPUT" | tail -100 | jq -Rs '.' || echo 'null')
            BUILD_RESULTS["$EXT"]="{\"id\": \"$EXT\", \"status\": \"$BUILD_STATUS\", \"buildTimeMs\": $BUILD_TIME, \"error\": $BUILD_ERROR}"
            BUILT_EXTS+=("$EXT")
            
            rm -f "$BUILD_OUTPUT"
          done
          
          # Wait for all background tests to complete
          echo "Waiting for tests to complete..."
          wait
          echo "All tests completed"
          
          # Build final results JSON with test results merged
          RESULTS_FILE="chunk-${{ matrix.chunk }}-results.json"
          echo '{"chunk": ${{ matrix.chunk }}, "extensions": [' > "$RESULTS_FILE"
          FIRST=true
          
          for EXT in "${BUILT_EXTS[@]}"; do
            [ "$FIRST" = true ] && FIRST=false || echo ',' >> "$RESULTS_FILE"
            
            BUILD_JSON="${BUILD_RESULTS[$EXT]}"
            EXT_SAFE="${EXT//\//-}"
            TEST_FILE="test-results/${EXT_SAFE}.json"
            
            if [ -f "$TEST_FILE" ]; then
              TEST_OUT=$(cat "$TEST_FILE")
              if echo "$TEST_OUT" | jq -e '.results' >/dev/null 2>&1; then
                TEST_JSON="$TEST_OUT"
              else
                ERROR_MSG=$(echo "$TEST_OUT" | head -c 500 | jq -Rs '.')
                TEST_JSON="{\"status\":\"error\",\"error\":$ERROR_MSG,\"results\":[]}"
              fi
              # Merge test into build result
              echo "$BUILD_JSON" | jq --argjson test "$TEST_JSON" '. + {test: $test}' >> "$RESULTS_FILE"
            else
              echo "$BUILD_JSON" >> "$RESULTS_FILE"
            fi
          done
          
          echo ']}' >> "$RESULTS_FILE"
      
      - name: Generate summary
        run: |
          RESULTS_FILE="chunk-${{ matrix.chunk }}-results.json"
          echo "## Build Results (Chunk ${{ matrix.chunk }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Extension | Build | pop | lat | srch | det | chap | page | img |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|-----|-----|------|-----|------|------|-----|" >> $GITHUB_STEP_SUMMARY
          
          jq -r '.extensions[] | 
            def test_icon(name): if .test.results then [.test.results[] | select(.test == name)] | if length == 0 then "â€”" elif .[0].passed then "âœ…" else "âŒ" end else "â€”" end;
            "| \(.id) | \(if .status == "success" then "âœ…" else "âŒ" end) | \(test_icon("popular")) | \(test_icon("latest")) | \(test_icon("search")) | \(test_icon("details")) | \(test_icon("chapters")) | \(test_icon("pages")) | \(test_icon("images")) |"
          ' "$RESULTS_FILE" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          BUILT=$(jq '[.extensions[] | select(.status == "success")] | length' "$RESULTS_FILE")
          FAILED=$(jq '[.extensions[] | select(.status == "failed")] | length' "$RESULTS_FILE")
          echo "**Built:** $BUILT | **Failed:** $FAILED" >> $GITHUB_STEP_SUMMARY
      
      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: chunk-results-${{ matrix.chunk }}
          path: chunk-${{ matrix.chunk }}-results.json
          retention-days: 1
      
      - name: Upload extensions
        uses: actions/upload-artifact@v4
        with:
          name: extensions-chunk-${{ matrix.chunk }}
          path: dist/extensions/
          retention-days: 1
          if-no-files-found: ignore

  # ============================================================================
  # Generate registry and deploy
  # ============================================================================
  registry:
    needs: [check-upstream, detect, build]
    if: always() && needs.detect.result == 'success' && needs.detect.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
      
      - name: Restore extension cache
        id: cache
        uses: actions/cache/restore@v4
        with:
          path: dist/extensions
          key: extensions-v1
          restore-keys: extensions-
      
      - name: Download extensions
        if: needs.build.result != 'skipped'
        uses: actions/download-artifact@v4
        with:
          path: dist/extensions/
          pattern: extensions-chunk-*
          merge-multiple: true
      
      - name: Download results
        if: needs.build.result != 'skipped'
        uses: actions/download-artifact@v4
        with:
          path: .cache/build-results/
          pattern: chunk-results-*
          merge-multiple: true
      
      - name: Check for extensions
        id: check
        run: |
          if [ -d "dist/extensions" ] && [ -n "$(ls -A dist/extensions 2>/dev/null)" ]; then
            echo "has_extensions=true" >> $GITHUB_OUTPUT
            echo "Found extensions to deploy"
          else
            echo "has_extensions=false" >> $GITHUB_OUTPUT
            echo "No extensions found - skipping deploy"
          fi
      
      - name: Generate registry
        if: steps.check.outputs.has_extensions == 'true'
        run: |
          mkdir -p dist
          
          echo '{"extensions":[' > dist/index.json
          FIRST=true
          # Extensions are in lang/name/ structure (e.g., all/ahottie/, en/mangapill/)
          for manifest in dist/extensions/*/*/manifest.json; do
            [ -f "$manifest" ] || continue
            [ "$FIRST" = true ] && FIRST=false || echo ',' >> dist/index.json
            cat "$manifest" >> dist/index.json
          done
          echo ']}' >> dist/index.json
          
          jq -c . dist/index.json > dist/index.min.json
      
      - name: Generate build report
        if: steps.check.outputs.has_extensions == 'true'
        run: bun scripts/generate-build-report.ts || echo "Report skipped"
      
      - name: Create index page
        if: steps.check.outputs.has_extensions == 'true'
        run: |
          COUNT=$(jq '.extensions | length' dist/index.json)
          echo "Extensions in registry: $COUNT"
          cat > dist/index.html << EOF
          <!DOCTYPE html>
          <html>
          <head>
            <title>Keiyoushi Extensions</title>
            <meta charset="utf-8">
            <style>
              body { font-family: system-ui; max-width: 800px; margin: 2rem auto; padding: 1rem; }
              a { color: #0066cc; }
              code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
              .stats { color: #666; }
            </style>
          </head>
          <body>
            <h1>Keiyoushi Extensions</h1>
            <p class="stats">$COUNT extensions available</p>
            <h2>Registry</h2>
            <ul>
              <li><a href="index.json">index.json</a></li>
              <li><a href="build-report.html">Build Report</a></li>
            </ul>
            <h2>Usage</h2>
            <pre><code>const registry = await fetch('https://YOUR_DOMAIN/index.json').then(r => r.json());
          const ext = await fetch(\`https://YOUR_DOMAIN/extensions/\${id}/extension.js\`).then(r => r.text());</code></pre>
            <p><a href="https://github.com/nemu-pm/tachiyomi-js">tachiyomi-js</a></p>
          </body>
          </html>
          EOF
      
      - name: Save extension cache
        if: steps.check.outputs.has_extensions == 'true'
        uses: actions/cache/save@v4
        with:
          path: dist/extensions
          key: extensions-v1-${{ github.run_id }}
      
      - name: Upload pages artifact
        if: steps.check.outputs.has_extensions == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: dist/
      
      - name: Deploy to GitHub Pages
        if: steps.check.outputs.has_extensions == 'true'
        uses: actions/deploy-pages@v4
      
      - name: Update commit tracker
        if: steps.check.outputs.has_extensions == 'true'
        uses: actions/github-script@v7
        env:
          KEIYOUSHI_COMMIT: ${{ needs.check-upstream.outputs.keiyoushi_commit }}
        with:
          script: |
            const commit = process.env.KEIYOUSHI_COMMIT;
            if (!commit) return;
            try {
              await github.rest.actions.createOrUpdateRepoVariable({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'KEIYOUSHI_LAST_COMMIT',
                value: commit
              });
            } catch (e) {
              console.log('Could not update variable:', e.message);
            }

    permissions:
      contents: write
      pages: write
      id-token: write
